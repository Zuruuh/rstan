use std::fmt::Display;

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum LexerToken {
    TokenReference,
    TokenUnion,
    TokenIntersection,
    TokenNullable,
    TokenOpenParentheses,
    TokenCloseParentheses,
    TokenOpenAngleBracket,
    TokenCloseAngleBracket,
    TokenOpenSquareBracket,
    TokenCloseSquareBracket,
    TokenComma,
    TokenVariadic,
    TokenDoubleColon,
    TokenDoubleArrow,
    TokenEqual,
    TokenOpenPhpdoc,
    TokenClosePhpdoc,
    TokenPhpdocTag,
    TokenDoctrineTag,
    TokenFloat,
    TokenInteger,
    TokenSingleQuotedString,
    TokenDoubleQuotedString,
    TokenDoctrineAnnotationString,
    TokenIdentifier,
    TokenThisVariable,
    TokenVariable,
    TokenHorizontalWs,
    TokenPhpdocEol,
    TokenOther,
    TokenEnd,
    TokenColon,
    TokenWildcard,
    TokenOpenCurlyBracket,
    TokenCloseCurlyBracket,
    TokenNegated,
    TokenArrow,
}

impl LexerToken {
    pub fn into_regex_string(self) -> String {
        match self {
            LexerToken::TokenReference => todo!(),
            LexerToken::TokenUnion => todo!(),
            LexerToken::TokenIntersection => todo!(),
            LexerToken::TokenNullable => todo!(),
            LexerToken::TokenOpenParentheses => todo!(),
            LexerToken::TokenCloseParentheses => todo!(),
            LexerToken::TokenOpenAngleBracket => todo!(),
            LexerToken::TokenCloseAngleBracket => todo!(),
            LexerToken::TokenOpenSquareBracket => todo!(),
            LexerToken::TokenCloseSquareBracket => todo!(),
            LexerToken::TokenComma => todo!(),
            LexerToken::TokenVariadic => todo!(),
            LexerToken::TokenDoubleColon => todo!(),
            LexerToken::TokenDoubleArrow => todo!(),
            LexerToken::TokenEqual => todo!(),
            LexerToken::TokenOpenPhpdoc => todo!(),
            LexerToken::TokenClosePhpdoc => todo!(),
            LexerToken::TokenPhpdocTag => todo!(),
            LexerToken::TokenDoctrineTag => todo!(),
            LexerToken::TokenFloat => todo!(),
            LexerToken::TokenInteger => todo!(),
            LexerToken::TokenSingleQuotedString => todo!(),
            LexerToken::TokenDoubleQuotedString => todo!(),
            LexerToken::TokenDoctrineAnnotationString => todo!(),
            LexerToken::TokenIdentifier => todo!(),
            LexerToken::TokenThisVariable => todo!(),
            LexerToken::TokenVariable => todo!(),
            LexerToken::TokenHorizontalWs => todo!(),
            LexerToken::TokenPhpdocEol => todo!(),
            LexerToken::TokenOther => todo!(),
            LexerToken::TokenEnd => todo!(),
            LexerToken::TokenColon => todo!(),
            LexerToken::TokenWildcard => todo!(),
            LexerToken::TokenOpenCurlyBracket => todo!(),
            LexerToken::TokenCloseCurlyBracket => todo!(),
            LexerToken::TokenNegated => todo!(),
            LexerToken::TokenArrow => todo!(),
        }
    }
}

impl Display for LexerToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::TokenReference => "\'&\'",
                Self::TokenUnion => "\'|\'",
                Self::TokenIntersection => "\'&\'",
                Self::TokenNullable => "\'?\'",
                Self::TokenNegated => "\'!\'",
                Self::TokenOpenParentheses => "\'(\'",
                Self::TokenCloseParentheses => "\')\'",
                Self::TokenOpenAngleBracket => "\'<\'",
                Self::TokenCloseAngleBracket => "\'>\'",
                Self::TokenOpenSquareBracket => "\'[\'",
                Self::TokenCloseSquareBracket => "\']\'",
                Self::TokenOpenCurlyBracket => "\'{\'",
                Self::TokenCloseCurlyBracket => "\'}\'",
                Self::TokenComma => "\",\'",
                Self::TokenColon => "\':\'",
                Self::TokenVariadic => "\'...\'",
                Self::TokenDoubleColon => "\'::\'",
                Self::TokenDoubleArrow => "\'=>\'",
                Self::TokenArrow => "\'->\'",
                Self::TokenEqual => "\'=\'",
                Self::TokenOpenPhpdoc => "\'/**\'",
                Self::TokenClosePhpdoc => "\'*/\'",
                Self::TokenPhpdocTag => "TOKEN_PHPDOC_TAG",
                Self::TokenDoctrineTag => "TOKEN_DOCTRINE_TAG",
                Self::TokenPhpdocEol => "TOKEN_PHPDOC_EOL",
                Self::TokenFloat => "TOKEN_FLOAT",
                Self::TokenInteger => "TOKEN_INTEGER",
                Self::TokenSingleQuotedString => "TOKEN_SINGLE_QUOTED_STRING",
                Self::TokenDoubleQuotedString => "TOKEN_DOUBLE_QUOTED_STRING",
                Self::TokenDoctrineAnnotationString => "TOKEN_DOCTRINE_ANNOTATION_STRING",
                Self::TokenIdentifier => "type",
                Self::TokenThisVariable => "\'$this\'",
                Self::TokenVariable => "variable",
                Self::TokenHorizontalWs => "TOKEN_HORIZONTAL_WS",
                Self::TokenOther => "TOKEN_OTHER",
                Self::TokenEnd => "TOKEN_END",
                Self::TokenWildcard => "*",
            }
        )
    }
}
